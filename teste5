#!/usr/bin/env python3
"""
Dashboard Test Suite v5 - VersÃ£o Corrigida
Sistema de testes integrados para o DashboardNext
"""

import asyncio
import json
import os
from datetime import datetime
from typing import Dict, List, Optional, Any
import pytest
import httpx
from pydantic import BaseModel, Field, validator


# ==================== MODELOS DE DADOS ====================

class NotaFiscal(BaseModel):
    """Modelo de nota fiscal com validaÃ§Ã£o"""
    id: str
    numero: str
    cliente: str
    data_emissao: str
    valor: float = Field(gt=0)
    produtos: List[Dict[str, Any]]
    
    @validator('data_emissao')
    def validate_date(cls, v):
        try:
            datetime.fromisoformat(v)
            return v
        except:
            raise ValueError('Data deve estar no formato ISO')


class TestConfig(BaseModel):
    """ConfiguraÃ§Ã£o dos testes"""
    base_url: str = "http://localhost:8000"
    timeout: float = 30.0
    mock_mode: bool = False
    verbose: bool = True


# ==================== CLIENTE DE TESTE ====================

class DashboardTestClient:
    """Cliente HTTP para testes do dashboard"""
    
    def __init__(self, config: TestConfig):
        self.config = config
        self.client = httpx.AsyncClient(
            base_url=config.base_url,
            timeout=config.timeout
        )
        self.results = []
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.client.aclose()
    
    async def test_endpoint(self, name: str, method: str, path: str, 
                          expected_status: int = 200, **kwargs) -> Dict:
        """Testa um endpoint especÃ­fico"""
        result = {
            "name": name,
            "method": method,
            "path": path,
            "status": "FAILED",
            "response_time": 0,
            "error": None,
            "data": None
        }
        
        start_time = datetime.now()
        
        try:
            if method == "GET":
                response = await self.client.get(path, **kwargs)
            elif method == "POST":
                response = await self.client.post(path, **kwargs)
            elif method == "PUT":
                response = await self.client.put(path, **kwargs)
            elif method == "DELETE":
                response = await self.client.delete(path, **kwargs)
            else:
                raise ValueError(f"MÃ©todo HTTP nÃ£o suportado: {method}")
            
            result["response_time"] = (datetime.now() - start_time).total_seconds()
            result["status_code"] = response.status_code
            
            if response.status_code == expected_status:
                result["status"] = "PASSED"
                if response.headers.get("content-type", "").startswith("application/json"):
                    result["data"] = response.json()
            else:
                result["status"] = "FAILED"
                result["error"] = f"Status esperado: {expected_status}, recebido: {response.status_code}"
                
        except Exception as e:
            result["status"] = "ERROR"
            result["error"] = str(e)
            result["response_time"] = (datetime.now() - start_time).total_seconds()
        
        self.results.append(result)
        
        if self.config.verbose:
            self._print_result(result)
        
        return result
    
    def _print_result(self, result: Dict):
        """Imprime resultado formatado"""
        status_colors = {
            "PASSED": "\033[92mâœ…",
            "FAILED": "\033[91mâŒ",
            "ERROR": "\033[93mâš ï¸"
        }
        
        icon = status_colors.get(result["status"], "â“")
        print(f"{icon} {result['name']} - {result['response_time']:.3f}s\033[0m")
        
        if result["error"]:
            print(f"   Erro: {result['error']}")
        
        if result.get("data") and self.config.verbose:
            preview = json.dumps(result["data"], indent=2)[:200]
            if len(json.dumps(result["data"])) > 200:
                preview += "..."
            print(f"   Dados: {preview}")


# ==================== SUITE DE TESTES ====================

class DashboardTestSuite:
    """Suite completa de testes do dashboard"""
    
    def __init__(self, config: TestConfig):
        self.config = config
        self.client = DashboardTestClient(config)
    
    async def run_all_tests(self) -> Dict[str, Any]:
        """Executa todos os testes"""
        print("\nğŸ§ª EXECUTANDO SUITE DE TESTES DO DASHBOARD\n")
        
        async with self.client as client:
            # Testes de infraestrutura
            await self._test_infrastructure(client)
            
            # Testes de API
            await self._test_api_endpoints(client)
            
            # Testes de integraÃ§Ã£o
            await self._test_integrations(client)
            
            # Testes de performance
            await self._test_performance(client)
        
        return self._generate_report()
    
    async def _test_infrastructure(self, client: DashboardTestClient):
        """Testes de infraestrutura bÃ¡sica"""
        print("\nğŸ“¡ TESTES DE INFRAESTRUTURA\n")
        
        await client.test_endpoint(
            name="Health Check",
            method="GET",
            path="/api/health"
        )
        
        await client.test_endpoint(
            name="API Documentation",
            method="GET",
            path="/docs"
        )
    
    async def _test_api_endpoints(self, client: DashboardTestClient):
        """Testes dos endpoints da API"""
        print("\nğŸ”Œ TESTES DE ENDPOINTS\n")
        
        # Notas Fiscais
        await client.test_endpoint(
            name="Listar Notas Fiscais",
            method="GET",
            path="/api/notas"
        )
        
        # Dashboard
        await client.test_endpoint(
            name="Dados do Dashboard",
            method="GET",
            path="/api/dashboard"
        )
        
        # Pedidos
        await client.test_endpoint(
            name="Listar Pedidos",
            method="GET",
            path="/api/pedidos"
        )
        
        # Produtos
        await client.test_endpoint(
            name="Listar Produtos",
            method="GET",
            path="/api/produtos"
        )
    
    async def _test_integrations(self, client: DashboardTestClient):
        """Testes de integraÃ§Ã£o com sistemas externos"""
        print("\nğŸ”— TESTES DE INTEGRAÃ‡ÃƒO\n")
        
        # Teste do proxy Tiny
        await client.test_endpoint(
            name="Proxy Tiny API",
            method="POST",
            path="/api/tiny-proxy",
            json={
                "endpoint": "notas.pesquisa",
                "params": {"situacao": 6}
            }
        )
    
    async def _test_performance(self, client: DashboardTestClient):
        """Testes de performance"""
        print("\nâš¡ TESTES DE PERFORMANCE\n")
        
        # Teste de carga simples
        tasks = []
        for i in range(5):
            task = client.test_endpoint(
                name=f"Carga Concorrente {i+1}",
                method="GET",
                path="/api/health"
            )
            tasks.append(task)
        
        await asyncio.gather(*tasks)
    
    def _generate_report(self) -> Dict[str, Any]:
        """Gera relatÃ³rio dos testes"""
        results = self.client.results
        
        total = len(results)
        passed = len([r for r in results if r["status"] == "PASSED"])
        failed = len([r for r in results if r["status"] == "FAILED"])
        errors = len([r for r in results if r["status"] == "ERROR"])
        
        avg_response_time = sum(r["response_time"] for r in results) / total if total > 0 else 0
        
        report = {
            "summary": {
                "total": total,
                "passed": passed,
                "failed": failed,
                "errors": errors,
                "success_rate": (passed / total * 100) if total > 0 else 0,
                "avg_response_time": avg_response_time
            },
            "results": results,
            "timestamp": datetime.now().isoformat()
        }
        
        self._print_report(report)
        
        return report
    
    def _print_report(self, report: Dict[str, Any]):
        """Imprime relatÃ³rio formatado"""
        summary = report["summary"]
        
        print(f"""
\nğŸ“Š RELATÃ“RIO FINAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total de testes:     {summary['total']}
âœ… Passou:           {summary['passed']}
âŒ Falhou:           {summary['failed']}
âš ï¸  Erros:           {summary['errors']}
Taxa de sucesso:     {summary['success_rate']:.1f}%
Tempo mÃ©dio:         {summary['avg_response_time']:.3f}s
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
        
        if summary['failed'] > 0 or summary['errors'] > 0:
            print("\nâŒ TESTES FALHADOS:")
            for result in report['results']:
                if result['status'] in ['FAILED', 'ERROR']:
                    print(f"  - {result['name']}: {result['error']}")
        
        if summary['success_rate'] == 100:
            print("\nğŸ‰ TODOS OS TESTES PASSARAM! SISTEMA 100% FUNCIONAL!")
        elif summary['success_rate'] >= 80:
            print("\nâš ï¸  Sistema parcialmente funcional. Verifique os erros.")
        else:
            print("\nâŒ Sistema com problemas crÃ­ticos. CorreÃ§Ã£o necessÃ¡ria.")


# ==================== TESTES UNITÃRIOS ====================

class TestDashboardValidations:
    """Testes unitÃ¡rios para validaÃ§Ãµes"""
    
    def test_nota_fiscal_validation(self):
        """Testa validaÃ§Ã£o de nota fiscal"""
        # Teste vÃ¡lido
        nota = NotaFiscal(
            id="nota_123",
            numero="12345",
            cliente="VIBRACOUSTIC",
            data_emissao="2025-01-20",
            valor=1000.50,
            produtos=[{"codigo": "PROD1", "quantidade": 10}]
        )
        assert nota.numero == "12345"
        
        # Teste invÃ¡lido - valor negativo
        with pytest.raises(ValueError):
            NotaFiscal(
                id="nota_124",
                numero="12346",
                cliente="VIBRACOUSTIC",
                data_emissao="2025-01-20",
                valor=-100,  # Valor negativo
                produtos=[]
            )
    
    def test_date_validation(self):
        """Testa validaÃ§Ã£o de datas"""
        # Data vÃ¡lida
        nota = NotaFiscal(
            id="nota_125",
            numero="12347",
            cliente="VIBRACOUSTIC",
            data_emissao="2025-01-20",
            valor=500,
            produtos=[]
        )
        assert nota.data_emissao == "2025-01-20"
        
        # Data invÃ¡lida
        with pytest.raises(ValueError):
            NotaFiscal(
                id="nota_126",
                numero="12348",
                cliente="VIBRACOUSTIC",
                data_emissao="20/01/2025",  # Formato incorreto
                valor=500,
                produtos=[]
            )


# ==================== FUNÃ‡ÃƒO PRINCIPAL ====================

async def main():
    """FunÃ§Ã£o principal de execuÃ§Ã£o dos testes"""
    
    # ConfiguraÃ§Ã£o
    config = TestConfig(
        base_url=os.getenv("API_URL", "http://localhost:8000"),
        timeout=30.0,
        mock_mode=os.getenv("MOCK_MODE", "false").lower() == "true",
        verbose=True
    )
    
    print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         ğŸš€ DASHBOARD TEST SUITE v5.0          â•‘
â•‘              VersÃ£o Corrigida                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ConfiguraÃ§Ã£o:
- URL Base: {config.base_url}
- Timeout: {config.timeout}s
- Mock Mode: {config.mock_mode}
    """)
    
    # Executa os testes
    suite = DashboardTestSuite(config)
    report = await suite.run_all_tests()
    
    # Salva relatÃ³rio
    report_file = f"test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(report_file, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"\nğŸ“„ RelatÃ³rio salvo em: {report_file}")
    
    # Retorna cÃ³digo de saÃ­da apropriado
    return 0 if report['summary']['success_rate'] == 100 else 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    exit(exit_code)