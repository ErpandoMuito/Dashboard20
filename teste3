#!/usr/bin/env python3
"""
Teste 3 - Dashboard v2.0
Teste de valida√ß√£o da implementa√ß√£o pragm√°tica com foco em confiabilidade
"""

import os
import sys
import subprocess
import time
import requests
import json
from datetime import datetime

# Cores para output
GREEN = '\033[92m'
RED = '\033[91m'
YELLOW = '\033[93m'
BLUE = '\033[94m'
RESET = '\033[0m'

class DashboardTeste3:
    def __init__(self):
        self.base_dir = "/Users/rodrigo/Documents/DashboardNovo/dashboard-v2/teste3"
        self.api_url = "http://localhost:8000"
        self.frontend_url = "http://localhost:3000"
        self.errors = []
        self.warnings = []
        
    def print_header(self, text):
        """Imprime cabe√ßalho formatado"""
        print(f"\n{BLUE}{'='*60}{RESET}")
        print(f"{BLUE}{text.center(60)}{RESET}")
        print(f"{BLUE}{'='*60}{RESET}\n")
        
    def print_success(self, text):
        """Imprime mensagem de sucesso"""
        print(f"{GREEN}‚úì {text}{RESET}")
        
    def print_error(self, text):
        """Imprime mensagem de erro"""
        print(f"{RED}‚úó {text}{RESET}")
        self.errors.append(text)
        
    def print_warning(self, text):
        """Imprime mensagem de aviso"""
        print(f"{YELLOW}‚ö† {text}{RESET}")
        self.warnings.append(text)
        
    def print_info(self, text):
        """Imprime informa√ß√£o"""
        print(f"  {text}")
        
    def check_environment(self):
        """Verifica ambiente e depend√™ncias"""
        self.print_header("Verificando Ambiente")
        
        # Verifica se o diret√≥rio teste3 existe
        if not os.path.exists(self.base_dir):
            self.print_error(f"Diret√≥rio {self.base_dir} n√£o encontrado")
            return False
            
        self.print_success("Diret√≥rio teste3 encontrado")
        
        # Verifica Docker
        try:
            subprocess.run(["docker", "--version"], capture_output=True, check=True)
            self.print_success("Docker instalado")
        except:
            self.print_error("Docker n√£o est√° instalado ou n√£o est√° no PATH")
            return False
            
        # Verifica Docker Compose
        try:
            subprocess.run(["docker-compose", "--version"], capture_output=True, check=True)
            self.print_success("Docker Compose instalado")
        except:
            self.print_error("Docker Compose n√£o est√° instalado ou n√£o est√° no PATH")
            return False
            
        # Verifica arquivo .env
        env_file = os.path.join(self.base_dir, ".env")
        if not os.path.exists(env_file):
            self.print_warning(".env n√£o encontrado - criando exemplo")
            self.create_env_example()
        else:
            self.print_success(".env encontrado")
            
        return True
        
    def create_env_example(self):
        """Cria arquivo .env de exemplo"""
        env_content = """# Configura√ß√µes do Dashboard v2.0 - Teste 3

# API do Tiny ERP
TINY_API_TOKEN=seu_token_aqui

# Redis
REDIS_URL=redis://redis:6379/0
REDIS_MAX_CONNECTIONS=50

# Backend
LOG_LEVEL=INFO
ENV=production
TINY_API_TIMEOUT=30
TINY_API_MAX_RETRIES=3

# Frontend
REACT_APP_API_URL=http://localhost:8000
NODE_ENV=production
"""
        env_path = os.path.join(self.base_dir, ".env")
        with open(env_path, 'w') as f:
            f.write(env_content)
        self.print_info(f"Arquivo .env criado em {env_path}")
        self.print_warning("Configure seu TINY_API_TOKEN antes de continuar")
        
    def check_services(self):
        """Verifica se os servi√ßos est√£o rodando"""
        self.print_header("Verificando Servi√ßos")
        
        services_ok = True
        
        # Verifica Redis
        try:
            subprocess.run(
                ["docker", "exec", "dashboard_redis", "redis-cli", "ping"],
                capture_output=True,
                check=True
            )
            self.print_success("Redis respondendo")
        except:
            self.print_error("Redis n√£o est√° respondendo")
            services_ok = False
            
        # Verifica Backend
        try:
            response = requests.get(f"{self.api_url}/health", timeout=5)
            if response.status_code == 200:
                self.print_success("Backend API respondendo")
                health_data = response.json()
                self.print_info(f"Status: {health_data.get('status', 'unknown')}")
            else:
                self.print_error(f"Backend retornou status {response.status_code}")
                services_ok = False
        except Exception as e:
            self.print_error(f"Backend n√£o est√° acess√≠vel: {str(e)}")
            services_ok = False
            
        # Verifica Frontend
        try:
            response = requests.get(self.frontend_url, timeout=5)
            if response.status_code == 200:
                self.print_success("Frontend respondendo")
            else:
                self.print_error(f"Frontend retornou status {response.status_code}")
                services_ok = False
        except Exception as e:
            self.print_error(f"Frontend n√£o est√° acess√≠vel: {str(e)}")
            services_ok = False
            
        return services_ok
        
    def test_api_endpoints(self):
        """Testa endpoints principais da API"""
        self.print_header("Testando Endpoints da API")
        
        endpoints = [
            {"method": "GET", "path": "/", "name": "Root"},
            {"method": "GET", "path": "/health", "name": "Health Check"},
            {"method": "GET", "path": "/health/detailed", "name": "Health Detalhado"},
            {"method": "GET", "path": "/api/v2/notas", "name": "Listar Notas"},
            {"method": "GET", "path": "/api/v2/pedidos", "name": "Listar Pedidos"},
            {"method": "GET", "path": "/api/v2/produtos", "name": "Listar Produtos"},
            {"method": "GET", "path": "/metrics", "name": "M√©tricas Prometheus"},
        ]
        
        all_ok = True
        
        for endpoint in endpoints:
            try:
                url = f"{self.api_url}{endpoint['path']}"
                response = requests.request(endpoint['method'], url, timeout=10)
                
                if response.status_code < 400:
                    self.print_success(f"{endpoint['name']}: {response.status_code}")
                    if endpoint['path'] == '/health/detailed':
                        data = response.json()
                        self.print_info(f"Redis: {data.get('redis', {}).get('status', 'unknown')}")
                        self.print_info(f"API Tiny: {data.get('tiny_api', {}).get('status', 'unknown')}")
                else:
                    self.print_error(f"{endpoint['name']}: {response.status_code}")
                    all_ok = False
                    
            except Exception as e:
                self.print_error(f"{endpoint['name']}: {str(e)}")
                all_ok = False
                
        return all_ok
        
    def test_redis_operations(self):
        """Testa opera√ß√µes b√°sicas do Redis"""
        self.print_header("Testando Redis")
        
        try:
            # Testa SET/GET
            test_key = "test:dashboard:key"
            test_value = json.dumps({"test": True, "timestamp": datetime.now().isoformat()})
            
            # SET
            subprocess.run([
                "docker", "exec", "dashboard_redis", 
                "redis-cli", "SET", test_key, test_value
            ], check=True)
            self.print_success("Redis SET funcionando")
            
            # GET
            result = subprocess.run([
                "docker", "exec", "dashboard_redis",
                "redis-cli", "GET", test_key
            ], capture_output=True, text=True, check=True)
            
            if test_value in result.stdout:
                self.print_success("Redis GET funcionando")
            else:
                self.print_error("Redis GET retornou valor incorreto")
                
            # DEL
            subprocess.run([
                "docker", "exec", "dashboard_redis",
                "redis-cli", "DEL", test_key
            ], check=True)
            self.print_success("Redis DEL funcionando")
            
            # Info memory
            result = subprocess.run([
                "docker", "exec", "dashboard_redis",
                "redis-cli", "INFO", "memory"
            ], capture_output=True, text=True, check=True)
            
            for line in result.stdout.split('\\n'):
                if 'used_memory_human' in line:
                    self.print_info(f"Mem√≥ria usada: {line.split(':')[1].strip()}")
                    
            return True
            
        except Exception as e:
            self.print_error(f"Erro ao testar Redis: {str(e)}")
            return False
            
    def check_logs(self):
        """Verifica logs dos servi√ßos"""
        self.print_header("Verificando Logs")
        
        services = ["redis", "backend", "frontend"]
        
        for service in services:
            try:
                result = subprocess.run([
                    "docker", "logs", f"dashboard_{service}", "--tail", "20"
                ], capture_output=True, text=True)
                
                error_count = result.stderr.lower().count('error')
                warning_count = result.stderr.lower().count('warning')
                
                if error_count > 0:
                    self.print_warning(f"{service}: {error_count} erros encontrados nos logs")
                else:
                    self.print_success(f"{service}: Sem erros nos logs recentes")
                    
                if warning_count > 0:
                    self.print_info(f"{service}: {warning_count} avisos nos logs")
                    
            except Exception as e:
                self.print_error(f"Erro ao verificar logs de {service}: {str(e)}")
                
    def generate_report(self):
        """Gera relat√≥rio final"""
        self.print_header("Relat√≥rio de Testes")
        
        total_errors = len(self.errors)
        total_warnings = len(self.warnings)
        
        if total_errors == 0:
            self.print_success(f"Todos os testes passaram! üéâ")
        else:
            self.print_error(f"Total de erros encontrados: {total_errors}")
            
        if total_warnings > 0:
            self.print_warning(f"Total de avisos: {total_warnings}")
            
        # Salva relat√≥rio
        report = {
            "timestamp": datetime.now().isoformat(),
            "errors": self.errors,
            "warnings": self.warnings,
            "status": "PASS" if total_errors == 0 else "FAIL"
        }
        
        report_path = os.path.join(os.path.dirname(__file__), "test_report.json")
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
            
        self.print_info(f"Relat√≥rio salvo em: {report_path}")
        
        return total_errors == 0
        
    def run(self):
        """Executa todos os testes"""
        self.print_header("Dashboard v2.0 - Teste 3")
        print("Teste de valida√ß√£o da implementa√ß√£o pragm√°tica")
        print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Verifica ambiente
        if not self.check_environment():
            self.print_error("Ambiente n√£o est√° configurado corretamente")
            return False
            
        # Pergunta se deve iniciar os servi√ßos
        print(f"\n{YELLOW}Os servi√ßos precisam estar rodando para continuar.{RESET}")
        response = input("Deseja iniciar os servi√ßos agora? (s/n): ").lower()
        
        if response == 's':
            self.print_info("Iniciando servi√ßos...")
            os.chdir(self.base_dir)
            subprocess.run(["docker-compose", "up", "-d"], check=True)
            self.print_info("Aguardando servi√ßos iniciarem...")
            time.sleep(15)
            
        # Verifica servi√ßos
        if not self.check_services():
            self.print_error("Servi√ßos n√£o est√£o funcionando corretamente")
            self.print_info("Execute: cd dashboard-v2/teste3 && docker-compose up -d")
            return False
            
        # Testa API
        self.test_api_endpoints()
        
        # Testa Redis
        self.test_redis_operations()
        
        # Verifica logs
        self.check_logs()
        
        # Gera relat√≥rio
        return self.generate_report()


if __name__ == "__main__":
    tester = DashboardTeste3()
    success = tester.run()
    sys.exit(0 if success else 1)